@rendermode InteractiveServer
@page "/device/{id}"
@attribute [Authorize]

@using PolekoWebApp.Data
@using Microsoft.EntityFrameworkCore
@using PolekoWebApp.Components.Dialogs
@using PolekoWebApp.Components.Services
@using System.ComponentModel
@inject IDbContextFactory<ApplicationDbContext> DbContextFactory
@inject ILogger<Device> Logger
@inject IDialogService DialogService
@inject SensorService SensorService

@* TODO sensor settings: interval, connect and fetch when not actively monitoring, is dhcp (in which case only have MAC stored in the db and on each connect get its new IP)? *@

<MudDialogProvider />
<PageTitle>@(Sensor is null ? "Błąd" : $"{Sensor.IpAddress ?? Sensor.MacAddress}")</PageTitle>

<MudItem sm="5" Class="ma-auto">
        @if (Sensor is null)
        {
            @if (Error)
            {
                <h1>Czujnik o podanym ID nie istnieje</h1>
            }
            else
            {
                <span>Ładowanie...</span>
                <br/>
                <MudProgressCircular Color="Color.Primary" Size="Size.Large" Class="ma-auto" Indeterminate="true"/>
            }
        }
        else
        {
            <h2 style="text-align: center" class="ma-3">@(Sensor.IpAddress ?? Sensor.MacAddress)</h2>
            <MudPaper Class="pa-4">
                <MudGrid Justify="Justify.Center" Spacing="4">
                    <MudItem xs="12" Class="d-flex justify-end">
                        @* only show settings to admin and superadmin *@
                        <AuthorizeView Roles="Admin, SuperAdmin">
                            <Authorized>
                                <MudIconButton Icon="@Icons.Material.Filled.Settings" aria-label="settings"
                                               OnClick="OpenSettings"/>
                            </Authorized>
                        </AuthorizeView>
                        @if (!Sensor.ManuallyStartFetch && Sensor.Fetching)
                        {
                            <MudIconButton Icon="@Icons.Material.Filled.Stop" Size="Size.Large"
                                           Color="Color.Error"
                                           Disabled="true"
                                           aria-label="stop fetching"/>
                        }
                        else
                        {
                            @if (!Sensor.Fetching)
                            {
                                <MudIconButton Icon="@Icons.Material.Filled.PlayArrow" Size="Size.Large"
                                               Color="Color.Tertiary"
                                               aria-label="start fetching"
                                               OnClick="StartTcpClient"/>
                            }
                            else
                            {
                                <MudIconButton Icon="@Icons.Material.Filled.Stop" Size="Size.Large"
                                               Color="Color.Error"
                                               aria-label="stop fetching"
                                               OnClick="StopTcpClient"/>
                            }
                        }
                    </MudItem>
                    <MudItem>
                        <MudPaper Height="90px" Width="140px" Class="d-flex flex-column justify-center align-center pa-3" Elevation="3">
                            <h3>Temperatura</h3>
                            <span style="font-size: 1.5rem">@Sensor.LastReading.Temperature.ToString("0.00")</span>
                        </MudPaper>
                    </MudItem>
                    <MudItem>
                        <MudPaper Height="90px" Width="140px" Class="d-flex flex-column justify-center align-center pa-3" Elevation="3">
                            <h3>Wilgotność</h3>
                            <span style="font-size: 1.5rem">@Sensor.LastReading.Humidity.ToString("0.00")</span>
                        </MudPaper>
                    </MudItem>
                </MudGrid>
            </MudPaper>
        }
</MudItem>


@code {
    [Parameter]
    public string? Id { get; set; }

    private bool Error { get; set; }
    private Sensor? Sensor { get; set; }
    private CancellationTokenSource _cancellationTokenSource = new();
    private bool _eventSubscribed;

    private async Task StartTcpClient()
    {
        _cancellationTokenSource = new CancellationTokenSource();
        if (!_eventSubscribed)
        {
            Sensor!.LastReadingChanged += OnLastReadingChanged;
            _eventSubscribed = true;
        }
        await SensorService.ConnectToSensor(Sensor!, _cancellationTokenSource.Token);
        StateHasChanged();
    }

    private async Task StopTcpClient()
    {
        if (_eventSubscribed)
        {
            Sensor!.LastReadingChanged -= OnLastReadingChanged;
            _eventSubscribed = false;
        }
        await SensorService.DisconnectFromSensor(Sensor!, _cancellationTokenSource);
        StateHasChanged();
    }
    
    private async Task OpenSettings()
    {
        var parameters = new DialogParameters<DeviceSettingsDialog> { { x => x.Sensor, Sensor } };
        var dialog = await DialogService.ShowAsync<DeviceSettingsDialog>("Ustawienia", parameters);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            var outSensor = (Sensor)result.Data;
            await SaveChangesToDb(outSensor);
            Sensor!.FetchInterval = outSensor.FetchInterval;
            Sensor!.ManuallyStartFetch = outSensor.ManuallyStartFetch;
            Sensor!.UsesDhcp = outSensor.UsesDhcp;
            StateHasChanged();
        }
    }

    private async Task SaveChangesToDb(Sensor sensor)
    {
        await using var dbContext = await DbContextFactory.CreateDbContextAsync();
        var sensorInDb = await dbContext.Sensors.FindAsync(Sensor!.SensorId);
        if (sensorInDb is null) return;
        sensorInDb.FetchInterval = sensor.FetchInterval;
        sensorInDb.UsesDhcp = sensor.UsesDhcp;
        sensorInDb.ManuallyStartFetch = sensor.ManuallyStartFetch;
        await dbContext.SaveChangesAsync();
    }

    private async void OnLastReadingChanged(object? sender, PropertyChangedEventArgs args)
    {
        await InvokeAsync(StateHasChanged);
    }

    protected override async Task OnInitializedAsync()
    {
        await using var dbContext = await DbContextFactory.CreateDbContextAsync();
        try
        {
            var sensor = SensorService.Sensors.FirstOrDefault(x => x.SensorId.ToString() == Id);
            if (sensor is null)
            {
                Error = true;
            }
            else
            {
                Sensor = sensor;
                Sensor.LastReadingChanged += OnLastReadingChanged;
                _eventSubscribed = true;
            }
        }
        catch (InvalidOperationException)
        {
            Error = true;
        }
        await base.OnInitializedAsync();
    }

}